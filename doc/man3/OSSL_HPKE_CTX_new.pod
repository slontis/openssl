=pod

=head1 NAME

OSSL_HPKE_CTX_new, OSSL_HPKE_CTX_free,
OSSL_HPKE_encap, OSSL_HPKE_decap,
OSSL_HPKE_seal, OSSL_HPKE_open, OSSL_HPKE_export,
OSSL_HPKE_suite_check, OSSL_HPKE_str2suite,
OSSL_HPKE_keygen, OSSL_HPKE_get_grease_value,
OSSL_HPKE_get_ciphertext_size, OSSL_HPKE_get_public_encap_size,
OSSL_HPKE_get_recommended_ikmelen,
OSSL_HPKE_CTX_set1_psk, OSSL_HPKE_CTX_set1_ikme,
OSSL_HPKE_CTX_set1_authpriv, OSSL_HPKE_CTX_set1_authpub,
OSSL_HPKE_CTX_get_seq, OSSL_HPKE_CTX_set_seq
- Hybrid Public Key Encryption (HPKE) functions

=head1 SYNOPSIS

 #include <openssl/hpke.h>

 OSSL_HPKE_CTX *OSSL_HPKE_CTX_new(int mode, OSSL_HPKE_SUITE suite,
                                  OSSL_LIB_CTX *libctx, const char *propq);

 void OSSL_HPKE_CTX_free(OSSL_HPKE_CTX *ctx);

 int OSSL_HPKE_CTX_set1_psk(OSSL_HPKE_CTX *ctx,
                            const char *pskid,
                            const unsigned char *psk, size_t psklen);
 int OSSL_HPKE_CTX_set1_authpriv(OSSL_HPKE_CTX *ctx, EVP_PKEY *privp);
 int OSSL_HPKE_CTX_set1_authpub(OSSL_HPKE_CTX *ctx,
                                unsigned char *pub,
                                size_t publen);
 int OSSL_HPKE_CTX_get_seq(OSSL_HPKE_CTX *ctx, uint64_t *seq);
 int OSSL_HPKE_CTX_set_seq(OSSL_HPKE_CTX *ctx, uint64_t seq);
 int OSSL_HPKE_CTX_set1_ikme(OSSL_HPKE_CTX *ctx,
                            const unsigned char *ikme, size_t ikmelen);

 int OSSL_HPKE_encap(OSSL_HPKE_CTX *ctx,
                     unsigned char *enc, size_t *enclen,
                     unsigned char *pub, size_t publen,
                     const unsigned char *info, size_t infolen);
 int OSSL_HPKE_decap(OSSL_HPKE_CTX *ctx,
                     const unsigned char *enc, size_t enclen,
                     EVP_PKEY *recippriv,
                     const unsigned char *info, size_t infolen);
 int OSSL_HPKE_seal(OSSL_HPKE_CTX *ctx,
                    unsigned char *ct, size_t *ctlen,
                    const unsigned char *aad, size_t aadlen,
                    const unsigned char *pt, size_t ptlen);
 int OSSL_HPKE_open(OSSL_HPKE_CTX *ctx,
                    unsigned char *pt, size_t *ptlen,
                    const unsigned char *aad, size_t aadlen,
                    const unsigned char *ct, size_t ctlen);
 int OSSL_HPKE_export(OSSL_HPKE_CTX *ctx,
                      unsigned char *secret,
                      size_t secret_len,
                      const unsigned char *label,
                      size_t labellen);

 int OSSL_HPKE_keygen(OSSL_LIB_CTX *libctx, const char *propq,
                      OSSL_HPKE_SUITE suite,
                      const unsigned char *ikm, size_t ikmlen,
                      unsigned char *pub, size_t *publen, EVP_PKEY **priv);

 int OSSL_HPKE_suite_check(OSSL_HPKE_SUITE suite);
 int OSSL_HPKE_get_grease_value(OSSL_LIB_CTX *libctx, const char *propq,
                                OSSL_HPKE_SUITE *suite_in,
                                OSSL_HPKE_SUITE *suite,
                                unsigned char *pub,
                                size_t *pub_len,
                                unsigned char *ct,
                                size_t ctlen);

 int OSSL_HPKE_str2suite(const char *str, OSSL_HPKE_SUITE *suite);
 size_t OSSL_HPKE_get_ciphertext_size(OSSL_HPKE_SUITE suite, size_t clearlen);
 size_t OSSL_HPKE_get_public_encap_size(OSSL_HPKE_SUITE suite);
 size_t OSSL_HPKE_get_recommended_ikmelen(OSSL_HPKE_SUITE suite);

=head1 DESCRIPTION

These functions provide an API for using the form of Hybrid Public Key
Encryption (HPKE) defined in RFC9180. Understanding the HPKE specification 
is likely required before using these APIs.  HPKE is used by various 
other IETF specifications, including the (draft) TLS Encrypted Client 
Hello (ECH) specification and others.

HPKE is a highly flexible consstruct supporting many optional inputs for the
various combinations in which modes and algorithms can be used.

=head2 Define'd symbols and data strutures

- Symbols are defined (in include/openssl/hpke.h) for each of the
IANA-allocated codepoints for HPKE modes ,e.g. OSSL_HPKE_MODE_BASE,
key encapsulation methods (KEMs), e.g. OSSL_HPKE_KEM_ID_X25519, key
derivation functions (KDFs), e.g. OSSL_HPKE_KDF_ID_SHA256 and
authenticated encryption with additional data (AEAD) algorithms,
e.g. OSSL_HPKE_AEAD_ID_AES_GCM_128.

- The combination of a KEM, KDF and AEAD is represented in the
OSSL_HPKE_SUITE data structure which maps to how HPKE is used
in various protocols, and in these APIs.

    typedef struct {
        uint16_t    kem_id;
        uint16_t    kdf_id;
        uint16_t    aead_id;
    } OSSL_HPKE_SUITE;

- String values for the names of modes and suites are also
defined, to assist with configuration settings, and an API is
also provided (OSSL_HPKE_str2suite()) for mapping from those
strings to an OSSL_HPKE_SUITE data structure.

- An OSSL_HPKE_CTX is an opaque data structure that maintains
internal state as HPKE operations are carried out.

=head2 Context Construct/Free

- OSSL_HPKE_CTX_new() sets up an opaque instance for internal HPKE
state as HPKE operations are carried out. The inputs required are
the HPKE mode and suite. The caller can optionally supply an overall library
context (see L<OSSL_LIB_CTX(3)>, and property query I<propq>.

- OSSL_HPKE_CTX_free() releases memory associated with
an OSSL_HPKE_CTX pointer, including free'ing the top level
data structure.

Each OSSL_HPKE_CTX can be used for multiple calles to OSSL_HPKE_seal()
or OSSL_HPKE_open(), but only a single call to OSSL_HPKE_encap() or
OSSL_HPKE_decap() can be done with a given OSSL_HPKE_CTX pointer.
In other words, calling OSSL_HPKE_encap() or OSSL_HPKE_decap() twice with the same
OSSL_HPKE_CTX will result in an error. It is also an error to use
the same OSSL_HPKE_CTX for both sender and receiver, so if e.g. one
process acts as both sender and reciver then two instances of 
OSSL_HPKE_CTX will be needed.

=head2 Sender APIs

The sender's goal is to use HPKE to encrypt "to" a public key, via use of a
KEM, then a KDF and finally an AEAD.  The first step is to encapsulate (using
OSSL_HPKE_encap()) a public value using the recipient's public key, (and to
internally derive secrets). This produces the encapsulated public value ("enc")
to be sent to the recipient in whatever protocol is using HPKE. Having done the
encapsulation step, teh sender can then make one or more calls to
OSSL_HPKE_seal() to encrypt plaintexts using the derived secret.

Note that the sequence of outputs from OSSL_HPKE_seal() use an internal
incremented "nonce" value so are generally presented for decryption in the same
order.

- OSSL_HPKE_encap() uses the, HPKE context, the recipient public value, an
optional "info" parameter (that can bind other protocol information such as
identifiers) and produces the encapsulated public value. In 
almost all cases the encapsulated public value corresponds to an
one-time use ephemeral private value created as part of the 
encapsulation process.

- OSSL_HPKE_seal() takes the HPKE context, the plaintext and optional
additional authenticated data (AAD) and emits the ciphertext to be
sent to the recipient, usually alongside the encapsulated public
value. 

=head2 Recipient APIs

Recipients using HPKE require a less ephemeral private value
so that the public value can be distirbuted to potential 
senders via whatever protocol is using HPKE. For this reason,
recipients will generally generate a key pair and will likely
need to manage their private key value using standard mechanism
outside this API. (Private keys use normal EVP_PKEY pointers
so equally normal private key management mechanisms can be used 
for the relevant values.)

In order to enable encapsulation, the recipient needs to make
it's public value available to the sender. As of now, there is
no HPKE-specific format defined for that - the relevant formatting
is intended defined by application/protocols that make use of HPKE. So,
ECH for example defines an ECHConfig data structure that
combines the public value with other ECH data items. Normal
library functions must therefore be used to extract the public
value in the required format based on the EVP_PKEY for the
private value.

- OSSL_HPKE_keygen() provides a way for recipients to generate
a key pair based on the HPKE suite to be used. The main output
is the EVP_PKEY pointer for the private value. An OSSL_LIB_CTX
and property string can be provided as optional inputs. 

The HPKE specification defines a deterministic key generation
scheme where the private value is derived from initial keying
material (IKM), so OSSL_HPKE_keygen() also has an option to
use that scheme. When NULL/0 values are provided instead of
a real IKM, then a randomly generated key for the relevant
suite will be produced.

- OSSL_HPKE_decap() takes as input the sender's 
encapsulated public value (produced by OSSL_HPKE_encap())
and the recipient's EVP_PKEY pointer re-generates
the secret derived by the sender. As before, an optional
"info" parameter allows for binding that derived secret
to other application/protocol artefacts.

- OSSL_HPKE_open() is used by the recipient to recover an
encrypted value sent to it, again with optional accompanying
AAD. As with OSSL_HPKE_seal() there is an internally 
incrementing nonce value to ciphertexts need to be presented
in the correct order.

=head2 Exporting Secrets

HPKE also defines a way to produce exported secrets for use by the
appclication. For this to work, the sender must have frst called
OSSL_HPKE_encap() and, in order to be able to derive the same exported secret,
the receiver must have called the corresponding OSSL_HPKE_decap().  In addition
the suite used when forming an OSSL_HPKE_CTX to be used for exporting secrets
must use the "fake" encryption algorithm denoted by
OSSL_HPKE_AEAD_ID_EXPORTONLY. (That means a single OSSL_HPKE_CTX instance
cannot be used for both "real" encryption and for exporting secrets.)

Once encapsulation/decapsulation is done either side can use the
OSSL_HPKE_export() operation to derive a new application-visible secret from
the internally derived secret and an application supplied label.

Multiple calls to OSSL_HPKE_export() with the same OSSL_HPKE_CTX
are allowed, though there is again an internally
incrementing nonce value so that the sequence of exported secrets
needs to be preserved by the application. The same or different
labels can be provided to each call, though again applications 
will need to keep track of what was used when.

=head2 Parameter Notes

Notes on the various kinds of input and output for these APIs:

- a NULL pointer is used to represent absence of an optional
pointer-type parameter; if an additional length is provided
(e.g. for a buffer) the length provided alongside the NULL
pointer should be zero

- libctx: an OSSL_LIB_CTX pointer, often NULL

- propq: a properties string to accompany the above, similarly likely NULL

- OSSL_HPKE_CTX is an HPKE context that allows for multiple 

- HPKE mode: one of OSSL_HPKE_MODE_BASE, OSSL_HPKE_MODE_PSK, OSSL_HPKE_MODE_AUTH or 
OSSL_HPKE_MODE_PSKAUTH, which are the modes defined in RFC9180

- suite: an OSSL_HPKE_SUITE value, with a kem_id, kdf_id and aead_id
each of which are of type uint16_t with the IANA-registered values
from RFC9180 allowed

- buffers: all buffers are presented to these APIs using a pair of parameters: 
an unsigned char* pointer <foo> and a size_t length value called <foo>len.

- for input/output buffers, the (pointer to the) length on input is the
caller-allocated buffer size, and the size-used on successful output. 
Buffers for plaintexts, ciphertexts, aad and other caller-provided values
can be any size, other buffers (e.g. for key material, aad, etc.)
may be limited at compile time to be at most OSSL_HPKE_MAXSIZE (256).

- private key values are handled as EVP_PKEY pointers. Public key values
are handled as buffers (as per the previous points), so for example, 
authpub is a buffer for the HPKE public value to be used for AUTH modes, 
and authpriv is an EVP_PKEY * for the HPKE private value to be used for 
AUTH modes

- pskid is a string/char* containing a string identifying a pre-shared key (PSK) - it 
must have a terminating NUL as do all good strings

- psk is a buffer containing a pre-shared key

- aad is a buffer for additional authenticated data

- info is a buffer for information to be bound to the HPKE exchange (generally
to "fold in" identity information)

- pub is the receiver's typically non-ephemeral public value to which a
sender will encrypt (basically an ECDH public key, though in future that
could be less true)

- enc is a buffer for the ephemeral encapsulaed public value generated
by the sender (encryptor) and to be used by the recipient (decryptor) 

- priv is the receiver's typically non-ephemeral ECDH private value for decryption
in EVP_PKEY form

- seq is a uint64_t representing the sequencing of encryptions when multiple
calls are made (to be XOR'd with an internal nonce - that type was chosen to
match other HPKE implemenations

=head2 AUthenicated HPKE Modes

- HPKE defines modes that support KEM-based authentication of the
sender (OSSL_HPKE_MODE_AUTH and OSSL_HPKE_MODE_PSKAUTH). This is done by
binding the sender's authentication private/public values into the
encapsulation/decapsulation operations. (For current suites that 
doesn't affect the size of the "enc" output.) The key used for
such modes must also use the same KEM as used for the overall
exchange. OSSL_HPKE_keygen() can be used to generate the private
value required. That private value (as an EVP_PKEY*) is then
injected into the OSSL_HPKE_CTX instance using the OSSL_HPKE_CTX_set1_authpriv() 
API.

The corresponding public value should be provided to the recipient
as a buffer. For NIST curves the uncompressed encoding of the
public value should be supplied. CFRG curves only have one
encoding. The public value can be used to modify the recipient's
OSSL_HPKE_CTX instance using the OSSL_HPKE_CTX_set1_authpub()
API. 

In both cases the OSSL_HPKE_CTX needs to be modified before
the call to the encapulation/decapsulation operation.

=head2 Pre-Shared Key HPKE modes

HPKE also defines a symmetric equivalent to the authentication
described above using a pre-shared key (PSK) and a PSK identifier
(a string). PSKs can be used with the OSSL_HPKE_MODE_PSK and
OSSL_HPKE_MODE_PSKAUTH modes. In this case the PSK is supplied
as a (binary) buffer and the PSK identified (pskid) as a string and both
must be used to modify the OSSL_HPKE_CTX before the
encapsulation/decapsulation operation via the OSSL_HPKE_CTX_set1_psk()
API.

Note that the OSSL_HPKE_MODE_PSKAUTH mode requires tha both
the PSK and the authentication public/private be supplied before
the encapsulation/decapsulation operation work.

=head2 Use of deterministic key generation for senders

The HPKE specification allows the deterministic key generation
option to be used by senders. That is generally undesirable as
it exposes the relevant secret to the application rather then
preserving it within the library. However, if an application
has to operate in this manner the IKM can be used to modify 
the sender's OSSL_HPKE_CTX instance using the OSSL_HPKE_CTX_set1_ikme()
API. As one would expect that needs to be called prior to the
call to OSSL_HPLE_encap().

=head2 Re-sequencing

In case some protocol has to deal with e.g. packet loss while still
being able to decrypt later arriving packets, we provide a way
to force the increment used for the nonce to the next subsequent
call to OSSL_HPKE_seal() or OSSL_HPKE_open(). The OSSL_HPLE_CTX_set_seq()
API can be used for such purposes.

Note that re-use of the same nonce and key with different plaintexts
is dangerous and can lead to loss of confidentiality. Applications
therefore need to exercise extreme caution in using this API (and
would be better off avoiding it probably.)

=head2 Protocol Convenience Functions 

We provide additional convenience APIs for protocols using
HPKE where the caller would otherwise need to know internal details
of local HPKE support and/or algorithms.

OSSL_HPKE_suite_check() checks if a specific HPKE cipher suite (a combination of
KEM, KDF and AEAD functions) is supported locally.

To assist with memory alliocation, OSSL_HPKE_get_ciphertext_size() provides a way
for the caller to know by how much cipertext is longer than plaintext.
(AEAD algoriths add a data integrity tag and so there is a small amount of
ciphertext expansion.)

OSSL_HPKE_get_public_encap_size() provides a way for senders to know how big
the encapsulated public value will be for a given HPKE suite.

OSSL_HPKE_get_recommended_ikmelen() allows the caller to get a recommendation
for how long (in octets) an IKM to use with a given suite. This is needed
in cases where the same public value needs to be (re-)generated by a 
sender before calling OSSL_HPKE_seal().

OSSL_HPKE_get_grease_value() produces values of the appropriate length (for the given
suite) so that a protocol using HPKE can send so-called GREASE (see RFC8701) values
that are harder to distinguish from a real use of HPKE.

OSSL_HPKE_str2suite() maps known strings HPKE cipher suites. String values are
defined in hpke.h. The suite strings recognised are comma-separated KEM, KDF
and AEAD names in that order, e.g. "x25519,hkdf-sha256,aes128gcm". This can
be used by e.g., command line tools that accept string form names for 
HPKE codepoints.

=head1 RETURN VALUES

Unless otherwise stated (e.g. if a size_t or pointer is returned), all
functions return 1 for success and 0 for failure. Where a pointer is
returned, a NULL value indicates an error. Where a size_t is returned,
a zero indicates an error.

=head1 EXAMPLES

This example demonstrates a minimal round-trip using HPKE.

    #include <stddef.h>
    #include <string.h>
    #include <openssl/hpke.h>
    #include <openssl/evp.h>

    /* 
     * this is big enough for this example, real code would need different 
     * handling
     */
    #define LBUFSIZE 48

    /* we'll do a round-trip, generating a key, encrypting and decrypting */
    int main(int argc, char **argv)
    {
        int hpke_mode=OSSL_HPKE_MODE_BASE;
        OSSL_HPKE_SUITE hpke_suite = OSSL_HPKE_SUITE_DEFAULT;
        OSSL_HPKE_CTX *ctx = NULL, *rctx = NULL;
        size_t publen=LBUFSIZE; unsigned char pub[LBUFSIZE];
        EVP_PKEY *priv = NULL;
        size_t enclen=LBUFSIZE; unsigned char enc[LBUFSIZE];
        size_t ctlen=LBUFSIZE; unsigned char ct[LBUFSIZE];
        size_t ptlen=LBUFSIZE; unsigned char pt[LBUFSIZE];
        size_t clearlen=LBUFSIZE; unsigned char clear[LBUFSIZE];
        size_t aadlen=LBUFSIZE; unsigned char aad[LBUFSIZE];
        size_t infolen=LBUFSIZE; unsigned char info[LBUFSIZE];

        memset(pt,0,LBUFSIZE);
        memset(aad,0,LBUFSIZE);
        memset(info,0,LBUFSIZE);
        strcpy((char*)pt,"a message not in a bottle");
        ptlen=strlen((char*)pt);

        /* generate receiver's key pair */
        if (OSSL_HPKE_keygen(NULL, NULL, hpke_suite, NULL, 0,
                             pub, &publen, &priv) != 1)
            goto err;

        /* sender's actions */
        if ((ctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, NULL, NULL)) == NULL)
            goto err;
        if (OSSL_HPKE_encap(ctx, enc, &enclen, pub, publen, info, infolen) != 1)
            goto err;
        if (OSSL_HPKE_seal(ctx, ct, &ctlen, aad, aadlen, pt, ptlen) != 1)
            goto err;

        /* receiver's actions */
        if ((rctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, NULL, NULL)) == NULL)
            goto err;
        if (OSSL_HPKE_decap(rctx, enc, enclen, priv, info, infolen) != 1) 
            goto err;
        if (OSSL_HPKE_open(rctx, clear, &clearlen, aad, aadlen, ct, ctlen) != 1)
            goto err;
        OSSL_HPKE_CTX_free(rctx);
        OSSL_HPKE_CTX_free(ctx);
        EVP_PKEY_free(priv);
        printf("All good\n");
        return 1;

    err:
        /* clean up */
        printf("Error!\n");
        OSSL_HPKE_CTX_free(rctx);
        OSSL_HPKE_CTX_free(ctx);
        EVP_PKEY_free(priv);
        return 0;
    }

=head1 DANGER

Note that the OSSL_HPKE_CTX_set_seq() API could be dangerous - if used with
GCM that could lead to nonce-reuse, which is a known danger. So avoid that
entirely, or be very very careful when using that API.

Use of an IKM value for deterministic key generation (via
OSSL_HPKE_CTX_set1_ikme() or OSSL_HPKE_keygen()) creates the potential for
leaking keys (or IKM values). Only use that if really needed and if you
understand how keys or IKM values could be abused.

=head1 SEE ALSO

The RFC9180 specification: https://datatracker.ietf.org/doc/rfc9180/

=head1 HISTORY

Initially developed by Stephen Farrell supported by OTF via
the DEfO project: https://defo.ie/

=head1 COPYRIGHT

Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
