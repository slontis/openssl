=pod

=head1 NAME

OSSL_HPKE_CTX_new, OSSL_HPKE_CTX_free,
OSSL_HPKE_encap, OSSL_HPKE_decap,
OSSL_HPKE_seal, OSSL_HPKE_open, OSSL_HPKE_export,
OSSL_HPKE_suite_check, OSSL_HPKE_str2suite,
OSSL_HPKE_keygen, OSSL_HPKE_get_grease_value,
OSSL_HPKE_get_ciphertext_size, OSSL_HPKE_get_public_encap_size,
OSSL_HPKE_get_recommended_ikmelen,
OSSL_HPKE_CTX_set1_psk, OSSL_HPKE_CTX_set1_ikme,
OSSL_HPKE_CTX_set1_authpriv, OSSL_HPKE_CTX_set1_authpub,
OSSL_HPKE_CTX_get_seq, OSSL_HPKE_CTX_set_seq
- Hybrid Public Key Encryption (HPKE) functions

=head1 SYNOPSIS

 #include <openssl/hpke.h>

 OSSL_HPKE_CTX *OSSL_HPKE_CTX_new(int mode, OSSL_HPKE_SUITE suite,
                                  OSSL_LIB_CTX *libctx, const char *propq);
 void OSSL_HPKE_CTX_free(OSSL_HPKE_CTX *ctx);

 int OSSL_HPKE_encap(OSSL_HPKE_CTX *ctx,
                     unsigned char *enc, size_t *enclen,
                     unsigned char *pub, size_t publen,
                     const unsigned char *info, size_t infolen);
 int OSSL_HPKE_seal(OSSL_HPKE_CTX *ctx,
                    unsigned char *ct, size_t *ctlen,
                    const unsigned char *aad, size_t aadlen,
                    const unsigned char *pt, size_t ptlen);

 int OSSL_HPKE_keygen(OSSL_LIB_CTX *libctx, const char *propq,
                      OSSL_HPKE_SUITE suite,
                      const unsigned char *ikm, size_t ikmlen,
                      unsigned char *pub, size_t *publen, EVP_PKEY **priv);
 int OSSL_HPKE_decap(OSSL_HPKE_CTX *ctx,
                     const unsigned char *enc, size_t enclen,
                     EVP_PKEY *recippriv,
                     const unsigned char *info, size_t infolen);
 int OSSL_HPKE_open(OSSL_HPKE_CTX *ctx,
                    unsigned char *pt, size_t *ptlen,
                    const unsigned char *aad, size_t aadlen,
                    const unsigned char *ct, size_t ctlen);

 int OSSL_HPKE_export(OSSL_HPKE_CTX *ctx,
                      unsigned char *secret,
                      size_t secret_len,
                      const unsigned char *label,
                      size_t labellen);

 int OSSL_HPKE_CTX_set1_authpriv(OSSL_HPKE_CTX *ctx, EVP_PKEY *priv);
 int OSSL_HPKE_CTX_set1_authpub(OSSL_HPKE_CTX *ctx,
                                unsigned char *pub,
                                size_t publen);
 int OSSL_HPKE_CTX_set1_psk(OSSL_HPKE_CTX *ctx,
                            const char *pskid,
                            const unsigned char *psk, size_t psklen);

 int OSSL_HPKE_CTX_get_seq(OSSL_HPKE_CTX *ctx, uint64_t *seq);
 int OSSL_HPKE_CTX_set_seq(OSSL_HPKE_CTX *ctx, uint64_t seq);

 int OSSL_HPKE_CTX_set1_ikme(OSSL_HPKE_CTX *ctx,
                             const unsigned char *ikme, size_t ikmelen);

 int OSSL_HPKE_suite_check(OSSL_HPKE_SUITE suite);
 int OSSL_HPKE_get_grease_value(OSSL_LIB_CTX *libctx, const char *propq,
                                OSSL_HPKE_SUITE *suite_in,
                                OSSL_HPKE_SUITE *suite,
                                unsigned char *enc,
                                size_t *enclen,
                                unsigned char *ct,
                                size_t ctlen);

 int OSSL_HPKE_str2suite(const char *str, OSSL_HPKE_SUITE *suite);
 size_t OSSL_HPKE_get_ciphertext_size(OSSL_HPKE_SUITE suite, size_t clearlen);
 size_t OSSL_HPKE_get_public_encap_size(OSSL_HPKE_SUITE suite);
 size_t OSSL_HPKE_get_recommended_ikmelen(OSSL_HPKE_SUITE suite);

=head1 DESCRIPTION

These functions provide an API for using the form of Hybrid Public Key
Encryption (HPKE) defined in RFC9180. Understanding the HPKE specification 
is likely required before using these APIs.  HPKE is used by various 
other IETF specifications, including the (draft) TLS Encrypted Client 
Hello (ECH) specification and others.

HPKE is a standardised, highly flexible construct for encrypting "to" a public
key that supports combinations of a key encapsulation method (KEM), a key
derivation function (KDF) and an authenticated encryption with additional data
(AEAD) algorithm, with optional sender authentication.

The sender and a receiver here will generally be using some application or
protocol making use of HPKE. For example, with ECH, the sender will be a
browser and the receiver will be a web server.

=head2 Identifiers and data strutures

An I<OSSL_HPKE_CTX> is an opaque data structure that maintains
internal state as HPKE operations are carried out. Each such
context involves use of a given I<mode> and I<suite> of 
algorithms, which represents the combination of a KEM, KDF and AEAD
in the I<OSSL_HPKE_SUITE> data structure.

    typedef struct {
        uint16_t    kem_id;
        uint16_t    kdf_id;
        uint16_t    aead_id;
    } OSSL_HPKE_SUITE;

Identifiers are defined for each of the HPKE modes and IANA-allocated KEM, KDF
and AEAD codepoints for HPKE are as shown below.

=over 4

=item B<OSSL_HPKE_MODE_BASE>

base mode without sender authentication, string form: "base"

=item B<OSSL_HPKE_MODE_PSK>

pre-shared key (PSK) authenticated mode, string form: "psk"

=item B<OSSL_HPKE_MODE_AUTH>

mode with with sender authentication via a KEM-based sender private, string form: "auth"

=item B<OSSL_HPKE_MODE_PSKAUTH>

combined PSK + KEM-based sender-authentication, string form: "pskauth"

=back

The KEM identifiers are:

=over 4

=item B<OSSL_HPKE_KEM_ID_P256>

Uses NIST p256 curve for KEM. IANA codepoint: 0x10, string form "p256"

=item B<OSSL_HPKE_KEM_ID_P384>

Uses NIST p384 curve for KEM. IANA codepoint: 0x11, string form "p384"

=item B<OSSL_HPKE_KEM_ID_P521>

Uses NIST p521 curve for KEM. IANA codepoint: 0x12, string form "p521"

=item B<OSSL_HPKE_KEM_ID_X25519>, 0x0020,  "X25519"

Uses CFRG X25519 curve for KEM. IANA codepoint: 0x20, string form: "x25519"

=item B<OSSL_HPKE_KEM_ID_X448>

Uses CFRG X448 curve for KEM. IANA codepoint: 0x21, string form: "x448"

=back

The KDF identifiers are:

=over 4

=item B<OSSL_HPKE_KDF_ID_HKDF_SHA256>

Uses HKDF-SHA256 for KDF. IANA codepoint: 0x01, string form: "hkdf-SHA256"

=item B<OSSL_HPKE_KDF_ID_HKDF_SHA384>

Uses HKDF-SHA284 for KDF. IANA codepoint: 0x02, string form: "hkdf-SHA384"

=item B<OSSL_HPKE_KDF_ID_HKDF_SHA512>

Uses HKDF-SHA512 for KDF. IANA codepoint: 0x03, string form: "hkdf-SHA512"

=back

The AEAD identifiers are:

=over 4

=item B<SSL_HPKE_AEAD_ID_AES_GCM_128>

Uses AES-GCM-128 as AEAD. IANA codepoint: 0x01, string form: "aes-gcm-128"

=item B<SSL_HPKE_AEAD_ID_AES_GCM_256>

Uses AES-GCM-128 as AEAD. IANA codepoint: 0x02, string form: "aes-gcm-256"

=item B<SSL_HPKE_AEAD_ID_CHACHA_POLY1305>

Uses AES-GCM-128 as AEAD. IANA codepoint: 0x03, "chacha20-poly1305"

=item B<SSL_HPKE_AEAD_ID_EXPORTONLY>

"Fake" AEAD identifier for exports. IANA codepoint: 0xFFFF

=back

The string forms for the identifiers above can assist with configuration
settings, and an API is also provided (OSSL_HPKE_str2suite()) for mapping from
a comma-separated list of strings to an OSSL_HPKE_SUITE data structure.

=head2 Context Construct/Free

OSSL_HPKE_CTX_new() sets up an opaque instance for internal HPKE
state as HPKE operations are carried out. The inputs required are
the HPKE I<mode> and I<suite>. The caller can optionally supply an overall library
context I<libctx> (see L<OSSL_LIB_CTX(3)>, and property query I<propq>.

OSSL_HPKE_CTX_free() releases memory associated with
an OSSL_HPKE_CTX instance, including freeing the top level
data structure.

Each OSSL_HPKE_CTX instance can be used for multiple calls to OSSL_HPKE_seal()
or OSSL_HPKE_open(), but only a single call to OSSL_HPKE_encap() or
OSSL_HPKE_decap() can be done with a given OSSL_HPKE_CTX instance.
In other words, calling OSSL_HPKE_encap() or OSSL_HPKE_decap() twice with the same
OSSL_HPKE_CTX instance will result in an error. It is also an error to use
the same OSSL_HPKE_CTX instance for both sender and receiver, so if one
process acts as both sender and receiver then two instances of 
OSSL_HPKE_CTX will be needed.

=head2 Sender APIs

A sender's goal is to use HPKE to encrypt "to" a public key, via use of a
KEM, then a KDF and finally an AEAD.  The first step is to encapsulate (using
OSSL_HPKE_encap()) the sender's public value using the recipient's public key, 
(I<pub>) and to internally derive secrets. This produces the encapsulated public value 
(I<enc>) to be sent to the recipient in whatever protocol is using HPKE. Having done the
encapsulation step, the sender can then make one or more calls to
OSSL_HPKE_seal() to encrypt plaintexts using the secret stored within
I<ctx>.

Note that the sequence of outputs from OSSL_HPKE_seal() use an internally
incremented "nonce" value so need to be presented for decryption in the correct
order.

OSSL_HPKE_encap() uses the HPKE context (I<ctx>), the recipient public value 
(I<pub>), an optional I<info> parameter that can bind other protocol information such as
identifiers, and produces the encapsulated public value (I<enc>).
Generally, the encapsulated public value (I<enc>) corresponds to a
single-use ephemeral private value created as part of the 
encapsulation process.

OSSL_HPKE_seal() takes the HPKE context (I<ctx>), the plaintext (I<pt>) and optional
additional authenticated data (I<aad>) and emits the ciphertext (I<ct>) to be
sent to the recipient, alongside the encapsulated public value (I<enc>) output from
OSSL_HPKE_encap(). 

=head2 Recipient APIs

Recipients using HPKE require a typically less ephemeral private value so that
the public value can be distirbuted to potential senders via whatever protocol
is using HPKE. For this reason, recipients will generally first generate a key
pair and will need to manage their private key value using standard mechanisms
outside the scope of this API. Private keys use normal L<EVP_PKEY(3)> pointers
so normal private key management mechanisms can be used for the relevant
values.

In order to enable encapsulation, the recipient needs to make it's public value
available to the sender. There is no generic HPKE format defined for that - the
relevant formatting is intended to be defined by the application/protocols that
makes use of HPKE. ECH for example defines an ECHConfig data structure that
combines the public value with other ECH data items. Normal library functions
must therefore be used to extract the public value in the required format based
on the L<EVP_PKEY(3)> for the private value.

OSSL_HPKE_keygen() provides a way for recipients to generate a key pair based
on the HPKE I<suite> to be used. The main output is the L<EVP_PKEY(3)> pointer
for the private value, I<priv>. I<libctx> and a property string (I<propq>) can
be provided as optional inputs. 

The HPKE specification also defines a deterministic key generation scheme where
the private value is derived from initial keying material (IKM), so
OSSL_HPKE_keygen() also has an option to use that scheme, using the I<ikm>
parameter. When NULL/0 values are provided instead of a real IKM, then a
randomly generated key for the relevant I<suite> will be produced.

OSSL_HPKE_decap() takes as input the sender's encapsulated public value
produced by OSSL_HPKE_encap() (I<enc>) and the recipient's L<EVP_PKEY(3)>
pointer (I<prov>), and then re-generates the internal secret derived by the
sender. As before, an optional I<info> parameter allows binding that derived
secret to other application/protocol artefacts.

OSSL_HPKE_open() is used by the recipient to recover an
encrypted value sent to it, again with optional accompanying
I<aad>. As with OSSL_HPKE_seal() there is an internally 
incrementing nonce value so ciphertexts need to be presented
in the correct order.

=head2 Exporting Secrets

HPKE defines a way to produce exported secrets for use by the
appclication. For this to work, the sender must have frst called
OSSL_HPKE_encap() and, in order to be able to derive the same exported secret,
and the receiver must have called the corresponding OSSL_HPKE_decap().  
The I<suite> used when forming an OSSL_HPKE_CTX to be used for exporting secrets
must use the "fake" encryption algorithm denoted by the identifier
I<OSSL_HPKE_AEAD_ID_EXPORTONLY>. (That means a single OSSL_HPKE_CTX instance
cannot be used for both "real" encryption and for exporting secrets.)

Once encapsulation/decapsulation is done either side can use the
OSSL_HPKE_export() operation to derive a new application-visible secret from
the internally derived secret and an application supplied I<label>.
The output exported secret will be returned in the I<secret> parameter.

Multiple calls to OSSL_HPKE_export() with the same OSSL_HPKE_CTX
are supported, though there is again an internally
incrementing nonce value so that the sequence of exported secrets
needs to be managed by the application. The same or different
I<label> values can be provided to each call, though again applications 
will need to keep track of what was used when.

=head2 Sender-authenicated HPKE Modes

HPKE defines modes that support KEM-based sender-authentication
(I<OSSL_HPKE_MODE_AUTH> and I<OSSL_HPKE_MODE_PSKAUTH>). This works by binding
the sender's authentication private/public values into the encapsulation and
decapsulation operations. (For current suites that doesn't affect the size of
the I<enc> output.) The key used for such modes must also use the same KEM as
used for the overall exchange. OSSL_HPKE_keygen() can be used to generate the
private value required. That private value (as an L<EVP_PKEY(3)>) is then
injected into the OSSL_HPKE_CTX instance (I<ctx>) using the
OSSL_HPKE_CTX_set1_authpriv() API via the I<autppriv> parameter.

The corresponding public value should be provided to the recipient as a buffer.
For NIST curves, the uncompressed encoding of the public value should be
supplied. CFRG curves only have one encoding. The public value can be used to
modify the recipient's OSSL_HPKE_CTX instance using the
OSSL_HPKE_CTX_set1_authpub() API with the relevant I<ctx> and I<authpub>
parameters. 

In both cases the OSSL_HPKE_CTX needs to be modified before the call to the
encapulation/decapsulation operation.

=head2 Pre-Shared Key HPKE modes

HPKE also defines a symmetric equivalent to the authentication described above
using a pre-shared key (PSK) and a PSK identifier (a string). PSKs can be used
with the OSSL_HPKE_MODE_PSK and OSSL_HPKE_MODE_PSKAUTH modes. In this case the
PSK is supplied as a (binary) buffer (I<psk>) and the PSK identifier (I<pskid>)
as a string and both must be supplied to modify the OSSL_HPKE_CTX before the
encapsulation/decapsulation operation via the OSSL_HPKE_CTX_set1_psk() API.
As PSKs are symmetric the same calls must happen on both sender and receiver
sides.

The OSSL_HPKE_MODE_PSKAUTH mode combines both forms of sender-authentication. 
Both the PSK and the authentication public/private be supplied before the
encapsulation/decapsulation operation will work.

=head2 Deterministic key generation for senders

HPKE allows the deterministic key generation option to be used by senders. That
is generally undesirable as it exposes the relevant secret to the application
rather then preserving it within the library and is more likely to result in
use of predictable values or values that leak. However, if an application
really has to operate in this manner then IKM can be used to modify the
sender's OSSL_HPKE_CTX instance using the OSSL_HPKE_CTX_set1_ikme() API with
the IKM supplied in the I<ikme> parameter. As one would expect that needs to be
called prior to the call to OSSL_HPLE_encap().

=head2 Re-sequencing

Some protocols may have to deal with packet loss while still being able to
decrypt arriving packets later. We provide a way to set the increment used for
the nonce to the next subsequent call to OSSL_HPKE_seal() or OSSL_HPKE_open().
The OSSL_HPLE_CTX_set_seq() API can be used for such purposes with the I<seq>
parameter value resetting the internal nonce to be used for the next call.

A baseline nonce value is established based on the encapsulation or
decapsulation operation and is then incremented by 1 for each call to seal or
open. (In other words, the I<seq> is a zero-based counter.)

If a caller needs to determine how many calls to seal or open have been made
the OSSL_HPKE_CTX_get_seq() API can be used to retrive the increment (in the
I<seq> output) that will be used in the next call to seal or open. That would
return 0 before the first call a sender made to OSSL_HPKE_seal() and 1 after
that first call. 

For compatibility with other implementations these I<seq> increments are
represented as a I<uint64_t>.

Note that re-use of the same nonce and key with different plaintexts is very
dangerous and can lead to loss of confidentiality. Applications therefore need
to exercise extreme caution in using these APIs and would be better off avoiding
them entirely probably.

=head2 Protocol Convenience Functions 

Additional convenience APIs allow the caller to access internal details of
local HPKE support and/or algorithms, such as parmamerer lengths.

OSSL_HPKE_suite_check() checks if a specific HPKE I<suite> 
is supported locally.

To assist with memory alliocation, OSSL_HPKE_get_ciphertext_size() provides a
way for the caller to know by how much cipertext will be longer than a
plaintext of length I<clearlen>.  (AEAD algoriths add a data integrity tag and
so there is a small amount of ciphertext expansion.)

OSSL_HPKE_get_public_encap_size() provides a way for senders to know how big
the encapsulated public value will be for a given HPKE I<suite>.

OSSL_HPKE_get_recommended_ikmelen() allows the caller to get a recommendation
for how long (in octets) an IKM to use with a given I<suite>. This is needed in
cases where the same public value needs to be (re-)generated by a sender before
calling OSSL_HPKE_seal().

OSSL_HPKE_get_grease_value() produces values of the appropriate length for a
given I<suite_in> value (or a random value if I<suite_in> is NULL) so that a
protocol using HPKE can send so-called GREASE (see RFC8701) values that are
harder to distinguish from a real use of HPKE. The buffer sizes should
be supplied on input. The output I<enc> value will have an appropriate
length for I<suite_out> and a random value, and the I<ct> output will be
a random value.

OSSL_HPKE_str2suite() maps input strings to HPKE cipher suites. The string form
values for KEMs, KDFs and AEADs allowed are as shown in the section on
identifiers.  The input I<str> should be a comma-separated string with a KEM,
KDF and AEAD name in that order, for example "x25519,hkdf-sha256,aes128gcm".
This can be used by command line tools that accept string form names for HPKE
codepoints.

=head2 Parameter Notes

Notes on the various kinds of input and output for these APIs:

=over 4

- NULL is used to represent absence of an optional pointer-type parameter; if
an additional length is provided (for example for a buffer) the length
provided alongside the NULL pointer should be zero

- I<libctx> is an OSSL_LIB_CTX pointer, often NULL

- I<propq> is a property query to accompany the above, similarly likely NULL

- OSSL_HPKE_CTX is an HPKE context

- buffers: all buffers are presented to these APIs using a pair of parameters:
an unsigned char* pointer I<foo> and a size_t length value called I<foolen>.

- for input/output buffers, the (pointer to the) length on input is the
caller-allocated buffer size, and the size-used on successful output. 
Buffers for plaintexts, ciphertexts, aad and other caller-provided values
can be any size, other buffers (for example for key material, aad, etc.)
may be limited at compile time to be at most OSSL_HPKE_MAXSIZE (256).

- private key values are handled as L<EVP_PKEY(3)> pointers. Public key values
are handled as buffers (as per the previous point), so for example, 
I<authpub> is a buffer for the HPKE public value to be used for AUTH modes, 
and I<authpriv> is an L<EVP_PKEY(3)> for the HPKE private value to be used for 
AUTH modes

- I<pskid> is a string/char* containing a string identifying a pre-shared key
(PSK) - it must have a terminating NUL as do all good strings

- I<psk> is a buffer containing a pre-shared key

- I<aad> is a buffer for additional authenticated data

- I<info> is a buffer for information to be bound to the HPKE exchange (generally
to "fold in" identity information)

- I<pub> is the receiver's typically non-ephemeral public value to which a
sender will encrypt (basically an ECDH public key, though in future that
could be less true)

- I<enc> is a buffer for the ephemeral encapsulaed public value generated
by the sender (encryptor) and to be used by the recipient (decryptor) 

- I<priv> is the receiver's typically non-ephemeral ECDH private value for decryption
in L<EVP_PKEY(3)> form

- I<seq> is a uint64_t representing the sequencing of encryptions when multiple
calls are made (to be XOR'd with an internal nonce - that type was chosen to
match other HPKE implemenations)

=back

=head1 RETURN VALUES

OSSL_HPKE_CTX_new() returns an OSSL_HPKE_CTX pointer or NULL on error. SSL_HPKE_CTX_free() has
no return.

OSSL_HPKE_encap(), OSSL_HPKE_decap(), OSSL_HPKE_seal(), OSSL_HPKE_open(),
OSSL_HPKE_export(), OSSL_HPKE_suite_check(), OSSL_HPKE_str2suite(),
OSSL_HPKE_keygen(), OSSL_HPKE_get_grease_value(), OSSL_HPKE_CTX_get_seq(),
OSSL_HPKE_CTX_set_seq(),
OSSL_HPKE_CTX_set1_psk(), OSSL_HPKE_CTX_set1_ikme(),
OSSL_HPKE_CTX_set1_authpriv(), OSSL_HPKE_CTX_set1_authpub(),
all return 1 for success or zero for error.

OSSL_HPKE_get_ciphertext_size(), OSSL_HPKE_get_public_encap_size(),
OSSL_HPKE_get_recommended_ikmelen() all return a size_t with the 
relevant value or zero on error.



=head1 EXAMPLES

This example demonstrates a minimal round-trip using HPKE.

    #include <stddef.h>
    #include <string.h>
    #include <openssl/hpke.h>
    #include <openssl/evp.h>

    /* 
     * this is big enough for this example, real code would need different 
     * handling
     */
    #define LBUFSIZE 48

    /* we'll do a round-trip, generating a key, encrypting and decrypting */
    int main(int argc, char **argv)
    {
        int hpke_mode=OSSL_HPKE_MODE_BASE;
        OSSL_HPKE_SUITE hpke_suite = OSSL_HPKE_SUITE_DEFAULT;
        OSSL_HPKE_CTX *ctx = NULL, *rctx = NULL;
        size_t publen=LBUFSIZE; unsigned char pub[LBUFSIZE];
        EVP_PKEY *priv = NULL;
        size_t enclen=LBUFSIZE; unsigned char enc[LBUFSIZE];
        size_t ctlen=LBUFSIZE; unsigned char ct[LBUFSIZE];
        size_t ptlen=LBUFSIZE; unsigned char pt[LBUFSIZE];
        size_t clearlen=LBUFSIZE; unsigned char clear[LBUFSIZE];
        size_t aadlen=LBUFSIZE; unsigned char aad[LBUFSIZE];
        size_t infolen=LBUFSIZE; unsigned char info[LBUFSIZE];

        memset(pt,0,LBUFSIZE);
        memset(aad,0,LBUFSIZE);
        memset(info,0,LBUFSIZE);
        strcpy((char*)pt,"a message not in a bottle");
        ptlen=strlen((char*)pt);

        /* generate receiver's key pair */
        if (OSSL_HPKE_keygen(NULL, NULL, hpke_suite, NULL, 0,
                             pub, &publen, &priv) != 1)
            goto err;

        /* sender's actions */
        if ((ctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, NULL, NULL)) == NULL)
            goto err;
        if (OSSL_HPKE_encap(ctx, enc, &enclen, pub, publen, info, infolen) != 1)
            goto err;
        if (OSSL_HPKE_seal(ctx, ct, &ctlen, aad, aadlen, pt, ptlen) != 1)
            goto err;

        /* receiver's actions */
        if ((rctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, NULL, NULL)) == NULL)
            goto err;
        if (OSSL_HPKE_decap(rctx, enc, enclen, priv, info, infolen) != 1) 
            goto err;
        if (OSSL_HPKE_open(rctx, clear, &clearlen, aad, aadlen, ct, ctlen) != 1)
            goto err;
        OSSL_HPKE_CTX_free(rctx);
        OSSL_HPKE_CTX_free(ctx);
        EVP_PKEY_free(priv);
        printf("All good\n");
        return 1;

    err:
        /* clean up */
        printf("Error!\n");
        OSSL_HPKE_CTX_free(rctx);
        OSSL_HPKE_CTX_free(ctx);
        EVP_PKEY_free(priv);
        return 0;
    }

=head1 DANGER

Note that the OSSL_HPKE_CTX_set_seq() API could be dangerous - if used with
GCM that could lead to nonce-reuse, which is a known danger. So avoid that
entirely, or be very very careful when using that API.

Use of an IKM value for deterministic key generation (via
OSSL_HPKE_CTX_set1_ikme() or OSSL_HPKE_keygen()) creates the potential for
leaking keys (or IKM values). Only use that if really needed and if you
understand how keys or IKM values could be abused.

=head1 SEE ALSO

The RFC9180 specification: https://datatracker.ietf.org/doc/rfc9180/

=head1 HISTORY

Initially developed by Stephen Farrell supported by OTF via
the DEfO project: https://defo.ie/

=head1 COPYRIGHT

Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
